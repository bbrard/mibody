#!/usr/bin/python
# -*- coding: utf-8 -*-

'''Parser for the output of the USB Mibody scales to a CSV format.'''

__author__ = 'Beno√Æt Brard <ben@brardb.net>'
__license__ = 'BSD'
__version__ = '0.1'


import argparse
import datetime
import sys


UNITS = ['lb', 'kg', 'st']


class ScaleRecord:

    def __init__(self, unit=UNITS[0]):
        self.unit = unit if unit in UNITS else UNITS[0]
        self.user = 0           # Numerical id.
        self.height = 0         # In cm.
        self.age = 0            # User's age in years.
        self.gender = 'M'       # Gender: M(ale) or F(emale).
        self.fitness_level = 0  # Fitness level from 1 to 3.
        self.weight = 0         # In units of 0.1 pound.
        self.bmi = 0            # In units of 0.1%.
        self.fat = 0            # In units of 0.1%.
        self.water = 0          # In units of 0.1%
        self.muscle = 0         # In units of 0.1%
        self.visceral_fat = 0
        self.bmr = 0            # Basal metabolec rate in kcal.
        self.datetime = datetime.datetime(2000, 1, 1)

    def init(self, byte_sequence):
        '''Initialize the values of a record from a byte sequence.'''
        if len(byte_sequence) == 24:
            # Extract the field from the binary data.
            user = byte_sequence[0]
            height = byte_sequence[1]
            age = byte_sequence[2]
            gender = byte_sequence[3] & 0x01
            fitness_level = byte_sequence[3] >> 4  # 4 last bits.
            weight = byte_sequence[4] + byte_sequence[5] * 256
            bmi = byte_sequence[6] + byte_sequence[7] * 256
            fat = byte_sequence[8] + byte_sequence[9] * 256
            water = byte_sequence[10] + byte_sequence[11] * 256
            muscle = byte_sequence[12] + byte_sequence[13] * 256
            visceral_fat = byte_sequence[14]
            # 15 is a 0x00 padding.
            bmr = byte_sequence[16] + byte_sequence[17] * 256
            year = 2000 + byte_sequence[18]
            month = byte_sequence[19]
            day = byte_sequence[20]
            hour = byte_sequence[21]
            minute = byte_sequence[22]
            second = byte_sequence[23]
            # Check the consistency of the values.
            # The existence of a padding byte is used as an extra check.
            if (user >= 1 and user <= 12
               and fitness_level >= 1 and fitness_level <= 3
               and byte_sequence[15] == 0):
                date = datetime.datetime.now()
                try:
                    date = datetime.datetime(year, month, day, hour,
                                             minute, second)
                    self.datetime = date
                except ValueError:
                    return False
                # Update the values of the object atomically.
                self.user = user
                self.height = height
                self.age = age
                self.gender = 'M' if gender else 'F'
                self.fitness_level = fitness_level
                self.weight = weight
                self.bmi = bmi
                self.fat = fat
                self.water = water
                self.muscle = muscle
                self.visceral_fat = visceral_fat
                self.bmr = bmr
                return True
        return False

    def lb_to_kg(weight):
        '''Convert pounds in kilograms.'''
        return weight * 0.453592

    def lb_to_st(weight):
        '''Convert pounds in stones.'''
        return weight * 0.0714286

    def __str__(self):
        '''Return the record as tab separeted string.'''
        weight = self.weight / 10.
        if self.unit == UNITS[1]:
            weight = ScaleRecord.lb_to_kg(weight)
        elif self.unit == UNITS[2]:
            weight = ScaleRecord.lb_to_st(weight)
        bmi = self.bmi / 10.
        fat = self.fat / 10.
        water = self.water / 10.
        muscle = self.muscle / 10.
        return '\t'.join(map(str, [self.datetime, self.user,
                                   '{0:.1f}'.format(weight), bmi, fat,
                                   water, muscle, self.visceral_fat, self.bmr,
                                   self.fitness_level, self.gender, self.height,
                                   self.age]))


class ScaleParser:
    '''Iterator over a file generated by a Mibody 9142 scale.'''

    def __init__(self, stream, unit=UNITS[0]):
        self.unit = unit if unit in UNITS else UNITS[0]
        self.stream = stream
        # The stream should be a sequence of 24 byte chunks.
        self.stream.seek(0, 2)
        if self.stream.tell() % 24 == 0:
            self.stream.seek(0, 0)
        else:
            sys.stderr.write('Wrong input size: {}\n'.format(self.stream.tell()))
            self.stream.close()

    def __iter__(self):
        return self

    def __next__(self):
        if not self.stream.closed and self.stream.readable():
            record = ScaleRecord(self.unit)
            chunk = self.stream.read(24)
            if chunk:
                if record.init(chunk):
                    return record
                else:
                    sys.stderr.write('Invalid chunk (parsing interrupted): '
                                     '{}\n'.format(chunk))
        self.stream.close()
        raise StopIteration


if __name__ == '__main__':
    opt_parser = argparse.ArgumentParser()
    opt_parser.add_argument('-o', '--output', type=str)
    opt_parser.add_argument('-u', '--unit', help='Weight unit', type=str,
                            choices=UNITS, default=UNITS[0])
    opt_parser.add_argument('input', type=str,
                            help='File produced by a Mibody 9142 scale')
    args = opt_parser.parse_args()
    try:
        istream = open(args.input, 'rb')
    except OSError:
        sys.stderr.write('This file does not exist: {}\n'.format(args.input))
        sys.exit(2)
    scale_parser = ScaleParser(istream, args.unit)
    ostream = sys.stdout
    if args.output:
        try:
            ostream = open(args.output, 'w')
        except OSError:
            sys.stderr.write('This file cannot be'
                             ' written: {}\n'.format(args.output))
            sys.exit(2)
    for record in scale_parser:
        ostream.write('{}\n'.format(str(record)))
